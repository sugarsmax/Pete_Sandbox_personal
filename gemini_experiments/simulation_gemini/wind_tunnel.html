<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>2D Car Wind Tunnel Simulation (Lattice Boltzmann)</title>
    <style>
        body {
            margin: 0;
            background: #111;
            color: #eee;
            font-family: sans-serif;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            image-rendering: pixelated;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #444;
            pointer-events: none;
            user-select: none;
        }

        h1 {
            margin: 0 0 10px 0;
            font-size: 1.2rem;
            color: #fff;
        }

        p {
            margin: 5px 0;
            font-size: 0.9rem;
            color: #aaa;
        }

        .key {
            color: #4af;
            font-weight: bold;
        }
    </style>
</head>

<body>

    <div id="controls">
        <h1>Wind Tunnel (LBM)</h1>
        <p>Left Click: <b>Draw Obstacles</b></p>
        <p>Right Click: <b>Clear Obstacles</b></p>
        <p>Key <span class="key">R</span>: Reset Simulation</p>
        <p>Key <span class="key">S</span>: Toggle Smoke Source</p>
        <p>Resolution: 200x100 (Scaled)</p>
    </div>

    <canvas id="simCanvas"></canvas>

    <script>
        /**
         * 2D Lattice Boltzmann Method (D2Q9) Fluid Simulation
         * Implements a virtual wind tunnel with a voxelized car shape.
         */

        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');

        // --- Simulation Parameters ---
        const width = 200;
        const height = 100;
        canvas.width = width;
        canvas.height = height;

        // Physics constants
        // Omega (1/tau): Determines viscosity. 
        // Values closer to 2.0 = Low Viscosity (more turbulent/unstable).
        // Values closer to 1.0 = High Viscosity (syrupy).
        const omega = 1.6;
        const turbulence = 0.02; // Inlet noise intensity

        // D2Q9 Lattice constants
        // Directions: Center(0), E(1), N(2), W(3), S(4), NE(5), NW(6), SW(7), SE(8)
        const ex = [0, 1, 0, -1, 0, 1, -1, -1, 1];
        const ey = [0, 0, 1, 0, -1, 1, 1, -1, -1];
        const w = [4 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 36, 1 / 36, 1 / 36, 1 / 36]; // Weights
        const opp = [0, 3, 4, 1, 2, 7, 8, 5, 6]; // Opposite direction indices

        // State Arrays (Float32 for performance)
        const nNodes = width * height;
        // Microscopic distributions (f) and temp buffer (newF)
        let f = new Float32Array(nNodes * 9);
        let newF = new Float32Array(nNodes * 9);
        // Macroscopic properties
        let rho = new Float32Array(nNodes); // Density
        let ux = new Float32Array(nNodes);  // Velocity X
        let uy = new Float32Array(nNodes);  // Velocity Y
        // Barrier map (1 if solid, 0 if fluid)
        let barrier = new Uint8Array(nNodes);

        // Visualizers
        const image = ctx.createImageData(width, height);
        const buffer32 = new Uint32Array(image.data.buffer);
        let smokeToggle = true;

        // --- Initialization ---

        function init() {
            // Initialize standard flow to the right
            const uStart = 0.1;
            for (let i = 0; i < nNodes; i++) {
                barrier[i] = 0;
                rho[i] = 1.0;
                ux[i] = uStart;
                uy[i] = 0.0;

                // Compute equilibrium
                const u2 = ux[i] * ux[i] + uy[i] * uy[i];
                for (let k = 0; k < 9; k++) {
                    const eu = ex[k] * ux[i] + ey[k] * uy[i];
                    f[i * 9 + k] = w[k] * rho[i] * (1 + 3 * eu + 4.5 * eu * eu - 1.5 * u2);
                }
            }
            createCarShape();
        }

        function createCarShape() {
            const cx = Math.floor(width / 3);
            const cy = Math.floor(height / 2) + 12;

            // Simple pixel-art aerodynamic shape
            const carPixels = [
                "       XXXXXX         ",
                "    XXXXXXXXXXXX      ",
                "  XXXXXXXXXXXXXXXX    ",
                " XXXXXXXXXXXXXXXXXX   ",
                "XXXXXXXXXXXXXXXXXXXX  ",
                " XX  XXXXXXXX  XX     ",
                " XX  XXXXXXXX  XX     "
            ];

            for (let y = 0; y < carPixels.length; y++) {
                for (let x = 0; x < carPixels[y].length; x++) {
                    if (carPixels[y][x] === 'X') {
                        const py = cy - (carPixels.length - y);
                        const px = cx + x;
                        if (px >= 0 && px < width && py >= 0 && py < height) {
                            barrier[py * width + px] = 1;
                            // Reset fluid in walls
                            ux[py * width + px] = 0;
                            uy[py * width + px] = 0;
                        }
                    }
                }
            }
        }

        // --- Physics Loop ---

        function collide() {
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = y * width + x;

                    if (barrier[i]) continue; // Skip solids (handled in stream)

                    // 1. Calculate macroscopic density and velocity
                    let density = 0;
                    let vx = 0;
                    let vy = 0;

                    for (let k = 0; k < 9; k++) {
                        const val = f[i * 9 + k];
                        density += val;
                        vx += val * ex[k];
                        vy += val * ey[k];
                    }

                    rho[i] = density;

                    if (density > 0) {
                        ux[i] = vx / density;
                        uy[i] = vy / density;
                    }

                    // 2. Relax towards Equilibrium (Collision)
                    const u2 = ux[i] * ux[i] + uy[i] * uy[i];
                    for (let k = 0; k < 9; k++) {
                        const eu = ex[k] * ux[i] + ey[k] * uy[i];
                        const feq = w[k] * density * (1 + 3 * eu + 4.5 * eu * eu - 1.5 * u2);
                        f[i * 9 + k] += omega * (feq - f[i * 9 + k]);
                    }
                }
            }
        }

        function stream() {
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = y * width + x;

                    for (let k = 0; k < 9; k++) {
                        // We want to know what flows INTO this cell (x,y) from direction k.
                        // It comes from neighbor (x - ex[k], y - ey[k])

                        const prevX = x - ex[k];
                        const prevY = y - ey[k];

                        if (prevX >= 0 && prevX < width && prevY >= 0 && prevY < height) {
                            const sourceIdx = prevY * width + prevX;

                            if (barrier[i]) {
                                // If I am a wall, I don't receive flow normally.
                            } else if (barrier[sourceIdx]) {
                                // Bounce-back: If the source is a wall, the particle that *would* have
                                // come from there is actually the particle leaving *this* cell in the
                                // opposite direction, reflected back.
                                f[i * 9 + k] = f[i * 9 + opp[k]];
                            } else {
                                // Normal propagation
                                newF[i * 9 + k] = f[sourceIdx * 9 + k];
                            }
                        }
                    }
                }
            }

            // Swap buffers
            let temp = f;
            f = newF;
            newF = temp;
        }

        function applyBoundaries() {
            const uIn = 0.12;

            // Inlet (Left) - Force constant velocity with noise
            for (let y = 0; y < height; y++) {
                const i = y * width + 0;
                if (!barrier[i]) {
                    const noise = (Math.random() - 0.5) * turbulence;
                    const uInLocal = uIn;
                    const vyIn = noise;

                    rho[i] = 1.0;
                    ux[i] = uInLocal;
                    uy[i] = vyIn;

                    const u2 = uInLocal * uInLocal + vyIn * vyIn;
                    for (let k = 0; k < 9; k++) {
                        const eu = ex[k] * uInLocal + ey[k] * vyIn;
                        f[i * 9 + k] = w[k] * 1.0 * (1 + 3 * eu + 4.5 * eu * eu - 1.5 * u2);
                    }
                }
            }

            // Outlet (Right) - Zero gradient
            for (let y = 0; y < height; y++) {
                const iEnd = y * width + (width - 1);
                const iPrev = y * width + (width - 2);
                for (let k = 0; k < 9; k++) {
                    f[iEnd * 9 + k] = f[iPrev * 9 + k];
                }
            }
        }

        // --- Rendering ---

        function render() {
            // Visualization: Vorticity (Curl) and Speed
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const i = y * width + x;

                    if (barrier[i]) {
                        buffer32[i] = 0xFF888888; // Gray walls
                        continue;
                    }

                    // Curl = dv/dx - du/dy
                    const uy_dx = uy[y * width + (x + 1)] - uy[y * width + (x - 1)];
                    const ux_dy = ux[(y + 1) * width + x] - ux[(y - 1) * width + x];
                    const curl = uy_dx - ux_dy;
                    const speed = Math.sqrt(ux[i] * ux[i] + uy[i] * uy[i]);

                    // Color Map
                    const r = Math.min(255, Math.max(0, 50 + curl * 1200));
                    const b = Math.min(255, Math.max(0, 50 - curl * 1200));
                    const g = Math.min(255, Math.max(0, 50 + speed * 600));

                    let brightness = Math.min(2.5, 0.8 + speed * 3);

                    let finalR = r * brightness;
                    let finalG = g * brightness;
                    let finalB = b * brightness;

                    // Smoke Lines
                    if (smokeToggle && x < 25 && y % 8 === 0) {
                        finalR = 255; finalG = 255; finalB = 255;
                    }

                    buffer32[i] = (255 << 24) | (finalB << 16) | (finalG << 8) | (finalR << 0);
                }
            }

            ctx.putImageData(image, 0, 0);
            // Upscale draw
            ctx.drawImage(canvas, 0, 0, width, height, 0, 0, canvas.width, canvas.height);
        }

        // --- Interaction ---

        let isDrawing = false;
        let isErasing = false;

        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor(((evt.clientX - rect.left) / rect.width) * width);
            const y = Math.floor(((evt.clientY - rect.top) / rect.height) * height);
            return { x, y };
        }

        canvas.addEventListener('mousedown', e => {
            if (e.button === 0) isDrawing = true;
            if (e.button === 2) isErasing = true;
            drawObstacle(e);
        });
        window.addEventListener('mouseup', () => { isDrawing = false; isErasing = false; });
        canvas.addEventListener('mousemove', drawObstacle);
        canvas.addEventListener('contextmenu', e => e.preventDefault());

        window.addEventListener('keydown', e => {
            if (e.key.toLowerCase() === 'r') init();
            if (e.key.toLowerCase() === 's') smokeToggle = !smokeToggle;
        });

        function drawObstacle(e) {
            if (!isDrawing && !isErasing) return;
            const pos = getMousePos(e);

            const brushSize = 2;
            for (let by = -brushSize; by <= brushSize; by++) {
                for (let bx = -brushSize; bx <= brushSize; bx++) {
                    const px = pos.x + bx;
                    const py = pos.y + by;
                    if (px >= 0 && px < width && py >= 0 && py < height) {
                        const idx = py * width + px;
                        barrier[idx] = isDrawing ? 1 : 0;
                        if (isErasing) {
                            ux[idx] = 0.1; uy[idx] = 0; rho[idx] = 1;
                        } else {
                            ux[idx] = 0; uy[idx] = 0;
                        }
                    }
                }
            }
        }

        // --- Main Loop ---

        function step() {
            // Multiple physics steps per render frame for stability
            const stepsPerFrame = 10;

            for (let i = 0; i < stepsPerFrame; i++) {
                applyBoundaries();
                collide();
                stream();
            }

            render();
            requestAnimationFrame(step);
        }

        // Start
        init();
        step();

    </script>
</body>

</html>